<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fault Recovery - The Kompact Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the Kompact actor-component-hybrid systems.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="../getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="../introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/components.html"><strong aria-hidden="true">1.1.</strong> Components</a></li><li class="chapter-item expanded "><a href="../introduction/actors.html"><strong aria-hidden="true">1.2.</strong> Actors</a></li><li class="chapter-item expanded "><a href="../introduction/state.html"><strong aria-hidden="true">1.3.</strong> Internal State</a></li></ol></li><li class="chapter-item expanded "><a href="../local/index.html"><strong aria-hidden="true">2.</strong> Local Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/index.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../local/communication/messagesandevents.html"><strong aria-hidden="true">2.1.1.</strong> Messages and Events</a></li><li class="chapter-item expanded "><a href="../local/communication/state.html"><strong aria-hidden="true">2.1.2.</strong> State</a></li><li class="chapter-item expanded "><a href="../local/communication/handlers.html"><strong aria-hidden="true">2.1.3.</strong> Handlers</a></li><li class="chapter-item expanded "><a href="../local/communication/ask.html"><strong aria-hidden="true">2.1.4.</strong> Ask</a></li><li class="chapter-item expanded "><a href="../local/communication/system.html"><strong aria-hidden="true">2.1.5.</strong> System</a></li><li class="chapter-item expanded "><a href="../local/communication/senders.html"><strong aria-hidden="true">2.1.6.</strong> Senders</a></li></ol></li><li class="chapter-item expanded "><a href="../local/timers.html"><strong aria-hidden="true">2.2.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../local/schedulers.html"><strong aria-hidden="true">2.3.</strong> Schedulers</a></li><li class="chapter-item expanded "><a href="../local/logging.html"><strong aria-hidden="true">2.4.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../local/configuration.html"><strong aria-hidden="true">2.5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../local/faultrecovery.html" class="active"><strong aria-hidden="true">2.6.</strong> Fault Recovery</a></li><li class="chapter-item expanded "><a href="../local/dynamic-components.html"><strong aria-hidden="true">2.7.</strong> Dynamic Components</a></li></ol></li><li class="chapter-item expanded "><a href="../distributed/index.html"><strong aria-hidden="true">3.</strong> Distributed Kompact</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/basiccommunication.html"><strong aria-hidden="true">3.1.</strong> Basic Communication</a></li><li class="chapter-item expanded "><a href="../distributed/namedservices.html"><strong aria-hidden="true">3.2.</strong> Named Services</a></li><li class="chapter-item expanded "><a href="../distributed/pathrouting.html"><strong aria-hidden="true">3.3.</strong> Path Routing</a></li><li class="chapter-item expanded "><a href="../distributed/serialisation.html"><strong aria-hidden="true">3.4.</strong> Serialisation</a></li><li class="chapter-item expanded "><a href="../distributed/networkbuffers.html"><strong aria-hidden="true">3.5.</strong> Configuring Buffers</a></li><li class="chapter-item expanded "><a href="../distributed/networkstatusport.html"><strong aria-hidden="true">3.6.</strong> Network Status Port</a></li></ol></li><li class="chapter-item expanded "><a href="../async/index.html"><strong aria-hidden="true">4.</strong> Async/Await Interaction</a></li><li class="chapter-item expanded affix "><a href="../project.html">Project Info</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Kompact Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kompics/kompact" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fault-recovery"><a class="header" href="#fault-recovery">Fault Recovery</a></h1>
<p>Sometimes panics can happen in components that provide crucial services to the rest of system. And while it is, of course, better to try and have <code>Result::Err</code> branches in place for every anticipated problem, with the use of 3rd party libraries and even some standard library functions not every possible panic can be prevented. Thus components can “fault” unexpectedly and the service they provide suddenly is not available.</p>
<p>In order to deal with cases where simply letting a component die is just not good enough, Kompact provdes a simple mechanism for recovering from faults: For every individual component, users can register a <code>RecoveryFunction</code>, that is basically a function which takes a <code>FaultContext</code> and produces a mechanism to recover from that fault, called a <code>RecoveryHandler</code>. This recovery handler is executed by the system’s <code>ComponentSupervisor</code> when it is informed of the fault.</p>
<blockquote>
<p><strong>Note:</strong> Fault recovery only works when the executed binary is compiled with <em>panic unwinding</em>. In binaries set to <code>panic=abort</code> none of this applies and fault handling must be dealt with outside the process running the Kompact system.</p>
</blockquote>
<blockquote>
<p><strong>Warning:</strong> Panicking within the <code>RecoveryHandler</code> will destroy the <code>ComponentSupervisor</code>, which is unrecoverable, and thus lead to “poisoning” of the whole Kompact system.</p>
</blockquote>
<p>A <code>RecoveryFunction</code> can be registered via <code>Component::set_recovery_function(...)</code> from outside a component or via <code>ComponentContext::set_recovery_function(...)</code> from within. Either way causes a <code>Mutex</code> to be locked, so be aware of the performance cost and the risk for deadlock when using with the latter function (since you are already holding the <code>Mutex</code> on the <code>ComponentDefinition</code> at this point). That being said, <code>set_recovery_function(...)</code> can be called repeatedly to update the state stored in the function. This is particularly useful as a very simple snapshotting mechanism, allowing a replacement component later to be started from this earlier state snapshort, instead of starting from scratch.</p>
<p>Apart from inspecting the <code>FaultContext</code> the recovery function must produce some kind of recovery handler. The simplest (and default) handler is <code>FaultContext::ignore()</code> which performs no additional action on the supervisor to recover the faulted component. If custom handling is required, it can be provided via <code>FaultContext::recover_with(...)</code>, where the user can provide a closure that may use the <code>FaultContext</code>, the supervisor’s <code>SystemHandle</code>, and the supervisor’s <code>KompactLogger</code> to react to the fault. What happens in this function is completely up to the user and the needs of the application. A common case might be to log some particular message, or create a new component via <code>system.create(...)</code> and start it with <code>system.start(...)</code>, for example.</p>
<blockquote>
<p><strong>Warning:</strong> Do <em>not</em> block within the <code>RecoveryHandler</code>, as that will prevent the <code>ComponentSupervisor</code> from doing its job. In particular, absolutely do not block on lifecycle event (e.g., <code>start_notify</code>) as that will deadlock the supervisor! If you need to execute a complicated sequence of asynchronous commands to recover from a fault, it is recommended to use a temporary component for this sequence, which can simply be started from the recovery handler.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> After recovery all component references (<code>Arc&lt;Component&lt;CD&gt;&gt;</code>) and actor references to the old component will be invalid. If your application needs their functionality, you need to devise a mechanism to share the new references (e.g., concurrent queues, <code>Arc&lt;Mutex&lt;...&gt;&gt;</code>, etc.). If the component provides a <a href="distributed/namedservices.html">named service</a> the alias must be re-registered to point to the new instance.</p>
</blockquote>
<h2 id="unstable-counter-example"><a class="header" href="#unstable-counter-example">Unstable Counter Example</a></h2>
<p>In order to showcase the recovery mechanism, we write a timer-based counter, which occasionally overflows and thus causes the component to crash. In order not to lose all the instances we have already counted, we will occasionally store the current count in the recovery function, and during recovery start from that point, i.e. a slightly outdated count, but at least not 0.</p>
<p>In addition to the current count, we will store references to two scheduled timers: For every <code>count_timeout</code> we want to increase our <code>count</code> by 1 and for every <code>state_timeout</code> we will update the recovery function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span>#[derive(ComponentDefinition, Actor)]
struct UnstableCounter {
    ctx: ComponentContext&lt;Self&gt;,
    count: u8,
    count_timeout: Option&lt;ScheduledTimer&gt;,
    state_timeout: Option&lt;ScheduledTimer&gt;,
}
<span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>By default, we just initialise the count to 0 and leave the timeouts unset until we are started.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Default for UnstableCounter {
    fn default() -&gt; Self {
        UnstableCounter {
            ctx: ComponentContext::uninitialised(),
            count: 0,
            count_timeout: None,
            state_timeout: None,
        }
    }
}
<span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>During start, we schedule the two timers and also set our recovery function. Within the recovery function, we simply store the state we want to remember, i.e. the two timeouts and the count. When it is called we produce a recovery handler from this state, that cancels the old timeouts and then starts a new <code>UnstableCounter</code> by passing in the last count we stored. </p>
<p>As usual, we also cancel our timeouts when we are stopped or killed.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl ComponentLifecycle for UnstableCounter {
    fn on_start(&amp;mut self) -&gt; Handled {
        let count_timeout = self.schedule_periodic(
            COUNT_TIMEOUT,
            COUNT_TIMEOUT,
            UnstableCounter::handle_count_timeout,
        );
        self.count_timeout = Some(count_timeout.clone());
        let state_timeout = self.schedule_periodic(
            STATE_TIMEOUT,
            STATE_TIMEOUT,
            UnstableCounter::handle_state_timeout,
        );
        self.state_timeout = Some(state_timeout.clone());
        let count = self.count;
        self.ctx.set_recovery_function(move |fault| {
            fault.recover_with(move |_ctx, system, logger| {
                warn!(
                    logger,
                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
                );
                // Clean up now invalid timers
                system.cancel_timer(count_timeout);
                system.cancel_timer(state_timeout);
                let counter_component = system.create(move || Self::with_state(count));
                system.start(&amp;counter_component);
            })
        });
        Handled::Ok
    }

    fn on_stop(&amp;mut self) -&gt; Handled {
        if let Some(timeout) = self.count_timeout.take() {
            self.cancel_timer(timeout);
        }
        if let Some(timeout) = self.state_timeout.take() {
            self.cancel_timer(timeout);
        }
        Handled::Ok
    }

    fn on_kill(&amp;mut self) -&gt; Handled {
        self.on_stop()
    }
}
<span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span>    fn with_state(count: u8) -&gt; Self {
        UnstableCounter {
            ctx: ComponentContext::uninitialised(),
            count,
            count_timeout: None,
            state_timeout: None,
        }
    }

<span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> Cancelling the timeouts during faults is not really necessary, as they will be cleaned automatically when the faulty component is dropped. Since we don’t control who is holding on to component references, though, it may avoid some unnecessary overhead on a heavily loaded timer if done more eagerly, like this. It is included here mostly as an example of possible cleanup code in a recovery handler.</p>
</blockquote>
<p>When our timeouts are triggered we must handle them. The count timeout is easy, we simply increment the <code>self.count</code> variable using the <code>checked_add</code> to cause a panic on overflow even in release builds. During the state timeout, we essentially reintroduce the recovery function from the <code>on_start</code> lifecycle handler, so that we update the state it closed over.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span>    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
        Handled::Ok
    }

    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
        info!(
            self.log(),
            &quot;Saving recovery state with count of {}&quot;, self.count
        );
        let mut count_timeout = self.count_timeout.clone();
        let mut state_timeout = self.state_timeout.clone();
        let count = self.count;
        self.ctx.set_recovery_function(move |fault| {
            fault.recover_with(move |_ctx, system, logger| {
                warn!(
                    logger,
                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
                );
                // Clean up now invalid timers
                if let Some(timeout) = count_timeout.take() {
                    system.cancel_timer(timeout);
                }
                if let Some(timeout) = state_timeout.take() {
                    system.cancel_timer(timeout);
                }
                let counter_component = system.create(move || Self::with_state(count));
                system.start(&amp;counter_component);
            })
        });
        Handled::Ok
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn main() {
</span><span class="boring">    let system = KompactConfig::default().build().expect(&quot;system&quot;);
</span><span class="boring">    let component = system.create(UnstableCounter::default);
</span><span class="boring">    system.start(&amp;component);
</span><span class="boring">    drop(component); // avoid it from holding on to memory after crashing
</span><span class="boring">    std::thread::sleep(Duration::from_millis(5000));
</span><span class="boring">    println!(&quot;Shutting down system&quot;);
</span><span class="boring">    system.shutdown().expect(&quot;shutdown&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>In order to run this, we simply start the default instance of the <code>UnstableCounter</code> onto a Kompact system and then wait for a bit to let it count. The output will show the counting and the crashes. We can see that after the crash do not start counting from 0, but instead from something much higher, around 199 depending on your exact timing. Also notice how we crash much faster after the first time, since it doesn’t take as long to reach 255 again.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#![allow(clippy::unused_unit)]
</span><span class="boring">use kompact::prelude::*;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">const COUNT_TIMEOUT: Duration = Duration::from_millis(10);
</span><span class="boring">const STATE_TIMEOUT: Duration = Duration::from_millis(1000);
</span><span class="boring">
</span><span class="boring">#[derive(ComponentDefinition, Actor)]
</span><span class="boring">struct UnstableCounter {
</span><span class="boring">    ctx: ComponentContext&lt;Self&gt;,
</span><span class="boring">    count: u8,
</span><span class="boring">    count_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">    state_timeout: Option&lt;ScheduledTimer&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl UnstableCounter {
</span><span class="boring">    fn with_state(count: u8) -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">    fn handle_count_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(self.log(), &quot;Incrementing count of {}&quot;, self.count);
</span><span class="boring">        self.count = self.count.checked_add(1).expect(&quot;Count overflowed!&quot;);
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn handle_state_timeout(&amp;mut self, _timeout_id: ScheduledTimer) -&gt; Handled {
</span><span class="boring">        info!(
</span><span class="boring">            self.log(),
</span><span class="boring">            &quot;Saving recovery state with count of {}&quot;, self.count
</span><span class="boring">        );
</span><span class="boring">        let mut count_timeout = self.count_timeout.clone();
</span><span class="boring">        let mut state_timeout = self.state_timeout.clone();
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                if let Some(timeout) = count_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                if let Some(timeout) = state_timeout.take() {
</span><span class="boring">                    system.cancel_timer(timeout);
</span><span class="boring">                }
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for UnstableCounter {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        UnstableCounter {
</span><span class="boring">            ctx: ComponentContext::uninitialised(),
</span><span class="boring">            count: 0,
</span><span class="boring">            count_timeout: None,
</span><span class="boring">            state_timeout: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ComponentLifecycle for UnstableCounter {
</span><span class="boring">    fn on_start(&amp;mut self) -&gt; Handled {
</span><span class="boring">        let count_timeout = self.schedule_periodic(
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            COUNT_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_count_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.count_timeout = Some(count_timeout.clone());
</span><span class="boring">        let state_timeout = self.schedule_periodic(
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            STATE_TIMEOUT,
</span><span class="boring">            UnstableCounter::handle_state_timeout,
</span><span class="boring">        );
</span><span class="boring">        self.state_timeout = Some(state_timeout.clone());
</span><span class="boring">        let count = self.count;
</span><span class="boring">        self.ctx.set_recovery_function(move |fault| {
</span><span class="boring">            fault.recover_with(move |_ctx, system, logger| {
</span><span class="boring">                warn!(
</span><span class="boring">                    logger,
</span><span class="boring">                    &quot;Recovering UnstableCounter based on last state count={}&quot;, count
</span><span class="boring">                );
</span><span class="boring">                // Clean up now invalid timers
</span><span class="boring">                system.cancel_timer(count_timeout);
</span><span class="boring">                system.cancel_timer(state_timeout);
</span><span class="boring">                let counter_component = system.create(move || Self::with_state(count));
</span><span class="boring">                system.start(&amp;counter_component);
</span><span class="boring">            })
</span><span class="boring">        });
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_stop(&amp;mut self) -&gt; Handled {
</span><span class="boring">        if let Some(timeout) = self.count_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        if let Some(timeout) = self.state_timeout.take() {
</span><span class="boring">            self.cancel_timer(timeout);
</span><span class="boring">        }
</span><span class="boring">        Handled::Ok
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_kill(&amp;mut self) -&gt; Handled {
</span><span class="boring">        self.on_stop()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn main() {
    let system = KompactConfig::default().build().expect(&quot;system&quot;);
    let component = system.create(UnstableCounter::default);
    system.start(&amp;component);
    drop(component); // avoid it from holding on to memory after crashing
    std::thread::sleep(Duration::from_millis(5000));
    println!(&quot;Shutting down system&quot;);
    system.shutdown().expect(&quot;shutdown&quot;);
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_unstable_counter() {
</span><span class="boring">        main();
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<blockquote>
<p><strong>Note:</strong> As before, if you have checked out the <a href="https://github.com/kompics/kompact/tree/master/docs/examples">examples folder</a> you can run the concrete binary with:</p>
<pre><code class="language-bash">cargo run --release --bin unstable_counter
</code></pre>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../local/configuration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../local/dynamic-components.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../local/configuration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../local/dynamic-components.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
